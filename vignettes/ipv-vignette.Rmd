---
title: "Item Pool Visualization"
author: "Nils Petras"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Item Pool Visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(IPV)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# IPV {#ipv}

Item Pool Visualization (IPV) is an original way to to display factor structures. IPV enables you to inspect and select an item pool based on its content. It can be used to assess and display the content validity of established tests in a specific context. At its core is the concept of center distance, a measure to compare factor loadings of different factor models. The original work on IPV is found in

*Dantlgraber, M., Stieger, S., & Reips, U.-D. (in revision). Introducing Item Pool Visualization (IPV)*

```{r, fig.width=10, fig.height=10, dpi=300, out.height="685px", out.width="685px", echo=FALSE}
sc_arrows <- data.frame(V1_factor=rep(NA,3),
                        V1_subfactor=rep(NA,3),
                        V2_factor=rep(NA,3),
                        V2_subfactor=rep(NA,3),
                        value=rep(NA,3))
sc_arrows[1,] <- c("DSSEI", "Ab", "RSES", "Ps", ".67")
sc_arrows[2,] <- c("DSSEI", "Ab", "SMTQ", "Cs", ".81")
sc_arrows[3,] <- c("SMTQ", "Ct", "RSES", "Ns", ".76")
coord <- coord_nested(self_confidence,
                      subradius = .6,
                      extra_arrows = sc_arrows,
                      rotate_radians = 4/3*pi,
                      subrotate_radians = c(pi/2,pi/2,0))
sc_nested <- plot_nested(coord,
                       filesave = FALSE,
                       size = 1.5,
                       colour_tests = "red",
                       colour_facets = "darkorange",
                       extra_arrows = TRUE)
sc_nested

```
Example of a nested chart, showing self-confidence measured by three different tests, each with multiple facets. All example data in this vignette from: *Dantlgraber, M., Stieger, S., & Reips, U.-D. (in revision). Introducing Item Pool Visualization (IPV)*

## Interpreting Charts

There are three chart types in IPV: **nested charts**, **facet charts**, and **item charts**. Nested charts display <span style="color:red">multiple tests</span> and <span style="color:darkorange">their facets</span>. Facet charts are the interior of the <span style="color:red">big circles</span> in the nested chart above, displaying one test and its facets. Item charts display the items of a test arranged by facets. For examples of [*a facet chart*](#fac) and [*an item chart*](#cd) see below.

In IPV, circles represent item pools. Smaller circles represent subpools. For example, each red circle encompasses several orange circles. The subpools represented by orange circles within a red circle add up to the item pool represented by that red circle. From each item pool, a factor is extracted, so each factor represents a set of items. The gray surrounding circle represents all items of the entire item pool. In the example above, the self-confidence of 2272 german speaking participants has been measured using three different tests: the *Domain Specific Self-Esteem Inventory (DSSEI)*, the *Sports Mental Toughness Questionnaire (SMTQ)*, and the *Rosenberg Self-Esteem Scale (RSES)*. So the surrounding gray circle is labeled *Self-Confidence*. In nested charts, there are two splits of the item pool. In the example, the overall item pool is split into <span style="color:red">three subpools</span>, which are split into <span style="color:darkorange">nine subpools</span>. Think of the interior of a circle as a further explanation of what that circle stands for. For example, within the DSSEI circle, its four facets are shown as a facet chart.

When splitting an item pool, there are more specified factors. The more factors are used, the more item variance can be explained. The items are better represented by more specific factors. For example, each test represents its items better, than the general *Self-Confidence* factor. The distance of the smaller circles (e.g. *DSSEI*) from the center of the larger circle (*Self-Confidence*) indicates exactly how much more variance is explained. The further away the inner edge of a circle is from the center of its surrounding circle, the more explanatory power it adds. So the *DSSEI* factor represents its 20 items only a little bit better than the general *Self-Confidence* factor. The gain is much more significant for the 10 *RSES* items, indicated by a larger distance of the *RSES* circle from the center. The concept of [*center distance*](#cd) is described in more detail below. In general, the further apart the circles are, the more important is the distinction of subpools.

Numbers within circles indicate latent correlations between factors. Optionally, arrows are drawn for selected latent correlations between facets of different tests. In this example, those exceeding the latent correlations between the tests are indicated.

## Models

IPV distinguishes between **simple models** and **nested models**.

**Simple models** consist of a single test and have two levels:

- **test level**: one factor representing the items of a test
- **facet level**: several correlated factors each representing the items of a facet of the test

**Nested models** combine multiple tests and have three levels:

- **global level**: one factor representing items combined from multiple tests
- **test level**: several correlated factors, each representing the items of a test
- **facet level**: several correlated factors each representing the items of a facet of a test

*Structure equation models (SEMs)* enable us to derive factors from an item pool. To estimate these SEMs, the factor structure of the tests has to be known in advance. In other words, which item belongs to which item pool has to be known in advance. Therefore, IPV is completely confirmatory. Factor loadings on each level are calculated only for the one factor the item is associated to.

- **global level**: one factor is estimated from all items combined (a *general factor model*). In the example above, this factor is *Self-Confidence*, estimated from 44 items.
- **test level**: for each test, one factor is estimated from the items of that test (a *correlated factor model*). In the example above, these three factors are *DSSEI* (estimated from the 20 *DSSEI* items), *SMTQ* (estimated from the 14 *SMTQ* items), and *RSES* (estimated from the 10 *RSES* items).
- **facet level**: for each facet, one factor is estimated from the items of that facet (a *correlated factor model*). In the example above, these nine factors are *Ab* (5 items), *Pb* (5 items), *Ph* (5 items), *So* (5 items), *Cf* (6 items), *Cs* (4 items), *Ct* (4 items), *Ns* (5 items), *Ps* (5 items).

It can be expected, that from the global to the facet level, factor loadings of items increase. The reason is, that the test level is more specific than the global level, and the facet level is more specific than the test level. The increase in factor loadings between the test and the facet level can be interpreted as the extend to which the facet of a test (e.g. *Ns*) is representing its items better than the overall test (e.g. *RSES*). The increase in factor loadings between the global and the test level can be interpreted as the extend to which the test (e.g. *RSES*) is representing its items better than the overall concept (e.g. *Self-Confidence*). The increase in factor loadings is measured as center distance.

## Center Distance {#cd}

An item pool can be represented by a general factor or multiple correlated factors for multiple subpools. **The center distance ($cd$) is the relative increase of the squared factor loading of an item on the correlated factor ($\lambda^2_c$) compared to the general factor ($\lambda^2_g$).** The center distance of a factor is the mean center distance of its items.

\begin{equation}
  cd = \frac{\lambda^2_c}{\lambda^2_g} -1
\end{equation}

For example, a center distance of 0.5 indicates that the correlated factor, estimated from a subpool, explains 50% more of the item variance compared to the general factor, estimated from the whole item pool. It could be, that the overall test score of a self-esteem test explains 20% of the variance of that item (squared factor loading = 0.2), while its facet explains 30% of the variance of that item (squared factor loading = 0.3), resulting in a relative increase of 50%. In IPVs, center distances are displayed as the distance to the center of the chart. In the [*example at the top*](#ipv), the center distances are displayed as the distance from the edge of the circles to the center. The center distances are marked by a thick radial line ending at the edge of the circle (red or orange). Axis scales are indicated by gray dotted circles, so values of center distances can be read from the chart. 

But you can also display center distances for single items in an item chart:

```{r, fig.width=10, fig.height=10, dpi=300, out.height="685px", out.width="685px"}
coord <- coord_items(SMTQ)
SMTQ_items <- plot_items(coord,
                         filesave = FALSE,
                         colour = "darkblue",
                         colour2 = "darkblue")
SMTQ_items

```

<span style="color:darkblue">Blue bars</span> represent items. Center distances are displayed as the distance from the origin to the inner edge of the bars. The items are arranged by facets on the radial arrows. Read center distance values from the grid of concentric circles, where steps of 0.5 are highlighted.

# Workflow

Before starting, calculate the structure equation models (SEMs) using your preferred statistical software. This package starts with the factor loadings and latent correlations of these models. To enable feeding in your SEM data, you can use the input_ functions. From there, **creating an IPV is a two step process using coord_ and plot_ functions**. Refine the appearance of your chart by reiteratively changing parameters of both of these functions and inspecting the result.

All charts are optimized for .pdf output, rather than output within R. This has three advantages:

1. You do not need to worry about any graphic settings.
2. You do not need to worry about saving your chart by hand. The chart is saved to your working directory (e.g. your R project within RStudio) on function call.
3. The chart is saved vector-based: the sweet magic that smoothes curves and fonts, and prevents your chart to be compromised by resolution or zoom.

When using the graphics output within RStudio, always use the zoom popout from the Plots widget, otherwise charts are heavily distorted.

## Data Preparation

Currently there are two ways to prepare your data: excel sheets or manual input in R. At the current beta state of this package I recommend using excel sheets.

When using data **input from excel**, you need to set up the cells matching the example files:
```{r, eval=FALSE}
system.file("extdata", "IPV_DSSEI.xlsx", package = "IPV")

# system.file(..., package = "IPV", ...) reads files that are installed with the IPV package to serve as examples
```
The easiest way is to use one of the files as a template by copying it and replacing the values.

On sheet 1 you need to provide the factor loadings from your SEM, on sheet 2 you need to provide latent correlations between the factors. Set up the following columns in sheet 1: "factor", "subfactor", "item", "factor_loading", "subfactor_loading". Each item will be a row. On sheet 2, set up the (named and complete) correlation matrix for the latent correlations between the correlated factors (=subfactors). Omit any empty rows and columns.

"factor" contains the general factor name, "factor_loading" the factor loadings of items on that factor (not squared). "subfactor" contains the correlated factor names, "subfactor_loading" the factor loadings of items on these factors (not squared). "item" contains the item names. Each row contains full information on the respective item: the factors it is associated to, the respective factor loadings, and the item name.

Read excel sheets using input_excel:

```{r,eval=FALSE}
# simple model
testfile <- system.file("extdata", "DSSEI.xlsx", package = "IPV", mustWork = TRUE)
x <- input_excel(tests = testfile)

# nested model
global <- system.file("extdata", "IPV_global.xlsx", package = "IPV", mustWork = TRUE)
tests <- c(system.file("extdata", "IPV_DSSEI.xlsx", package = "IPV", mustWork = TRUE),
             system.file("extdata", "IPV_SMTQ.xlsx", package = "IPV", mustWork = TRUE),
             system.file("extdata", "IPV_RSES.xlsx", package = "IPV", mustWork = TRUE))
x <- input_excel(global = global, tests = tests)

# system.file(..., package = "IPV", ...) reads files that are installed with the IPV package to serve as examples
```


Note, that center distances are calculated automatically. You will be warned if factor loadings or center distances had to be corrected. Factor loadings below 0.1 will be set to 0.1 and center distances below 0 will be set to 0 to ensure sensible chart margins.

For **manual data input**, a helper function is planned.

Consider issuing desired input options on [github](https://github.com/NilsPetras/IPV/issues).

## Chart Creation {#fac}

Call ?IPV for an overview of the functions.

Functions are named according to the chart concept, e.g. coord_items is needed to create an item chart. You will have to use two functions in conjunction. The first function is the *coord function* and prepares coordinates and labels for chart objects. The second function is the *plot function* and creates both a ggplot object and a .pdf file, the actual chart. So for each chart concept there are two functions.

For example, creating a facet chart works like this:

```{r,fig.width=10, fig.height=10, dpi=300, out.height="685px", out.width="685px"}
coord <- coord_facets(SMTQ, subradius = .6)
SMTQ_facets <- plot_facets(coord, filesave = FALSE)
SMTQ_facets
```

As you can see, almost all function parameters have a default value, so you can start fast and frugal. The chart is saved to a nameless .pdf file in your working directory by default. Provide a filename using the filename parameter. You can suppress file creation using the filesave parameter.

There is a useful shortcut for nested models. The function coord_nested always also generates coordinates for facet charts. If you set items = TRUE, you also get coordinates for the item charts in one go:

```{r,eval=FALSE}
coord <- coord_nested(self_confidence, subradius = .6, items = TRUE)
DSSEI_items <- plot_items(coord$items$DSSEI, filesave = FALSE)

```
Note that item chart coordinates are living in coord\$items and facet chart coordinates in coord\$factors

## Design Choices

The vast majority of parameters are size parameters for single elements of the chart, all named size_xyz or width_xyz. Those are pretty straightforward: linear scaling sizes defaulting to 1. Some other parameters are self-explanatory. These important parameters are more complex:

- **size** scales all elements of the chart. Not all elements are scaled linearly to produce harmonious results across a variety of sizes ("smart scaling"). **If you were limited to one cosmetic parameter, this would be the one**
- **colour**, **colour2**, **colour_tests**,**colour_facets** [full set of colours including gray](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). Colours are used to add visual contrast to important parts of the chart, I recommend using colours whenever possible. In the item chart, use different tones for *colour2* and *colour* to make overlapping items more visible.
- **relative_scaling** of the global and the test level in nested charts. For a clear chart, you need to hit the sweet spot between a) sizing up for readability and b) emphasize relative positions by creating gaps.
- **extra_arrows** adds custom correlation arrows to nested charts. Provide information about latent correlations between facets of different factors to the coord_nested (as below). Set *extra_arrows* = TRUE in plot_nested. Straighten out your chart with the subrotate parameters.

```{r}
sc_arrows <- data.frame(V1_factor=rep(NA,3),
                        V1_subfactor=rep(NA,3),
                        V2_factor=rep(NA,3),
                        V2_subfactor=rep(NA,3),
                        value=rep(NA,3))
sc_arrows[1,] <- c("DSSEI","Ab","RSES","Ps",".67")
sc_arrows[2,] <- c("DSSEI","Ab","SMTQ","Cs",".81")
sc_arrows[3,] <- c("SMTQ","Ct","RSES","Ns",".76")
sc_arrows
```
