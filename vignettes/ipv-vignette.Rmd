---
title: "Item Pool Visualization"
author: "Nils Petras"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Item Pool Visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(IPV)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## About this package

The IPV package is a tool to create IPV charts. The original work on IPV, including the chart concepts, can be found in:
[Dantlgraber, M., Stieger, S., & Reips, U. D. (2019). Introducing Item Pool Visualization: A method for investigation of concepts in self-reports and psychometric tests. Methodological Innovations, 12(3), 2059799119884283.](https://doi.org/10.1177/2059799119884283). Please cite this paper when using the package.
The package is built to enable chart creation quick & dirty or highly customized. Feel free to raise an [issue on github](https://github.com/NilsPetras/IPV/issues) in case of bugs or to make suggestions.

### Terminology

Although the following terminology will intuitively fit many practical purposes, IPV can be used for any possible subdivision of an item pool on multiple levels of specificity (see Dantlgraber et al., 2019).

"Item"s are single indicator variables within an item pool. A "test" (e.g. a questionnaire) is an item pool consisting of several "item"s. Within the "test", the "item"s may (or may not) be organized within smaller item pools ("facets"). If the data contains multiple tests of an overall "construct", this will be called a "nested" case. In such a case, the item pools of each "test" are nested within an overall item pool of the "construct".

## Workflow

The IPV package provides functions for the following steps:

1. estimate models (recommended) or read existing estimates
2. Create, customize, and save IPV charts

Call `?IPV` for an overview of all functions.


### 1a. Estimate Models

The `ipv_est()` function is recommended for model estimation, because it automatically formats the results for chart creation. It provides the lavaan objects of the estimated models, raw estimates of factor loadings and latent correlations, and center distances.

To use this function, your data needs to be formatted as follows:

- all items (indicator variables) are (numeric) columns of a data frame
- the data frame contains only those variables used in the models (or use indexing as in the example)
- all columns are named according to the pattern "test_facet_item"
- all variable names are unique
- all item names ("..._..._item") are unique at the level of the test (not only at the level of the facet!)
- tests without facets use the pattern "test_item"
- in the simple case of a single test, the pattern is "facet_item"

The function automatically determines which models to estimate, uses the [lavaan package](https://lavaan.ugent.be/) to estimate them, and provides formatted results.

For example:
```{r, echo = FALSE}
HEXACO[1:3, 2:4]
```

H = honesty/humility ("test")

Sinc = sincerity (a "facet" of honesty/humility)

Sinc_1 = first "item" of the sincerity facet

```{r, eval = FALSE}
# nested case: honesty/humility and agreeableness as "tests" (= sub-pools)
# of an overarching "construct" (= item pool)
res_HA <- ipv_est(dat = HEXACO[ ,c(2:41, 122:161)], name = "HA")
# simple case: agreeableness only
res_A <- ipv_est(dat = HEXACO[ ,c(122:161)], name = "A")
```

Results are provided as a list with the following elements:

- "lav": the lavaan object for each estimated model (optional)

- "est_raw": estimates (factor loadings, latent correlations) structured based on the item pools, (optional)

- "est": pre-formatted list of center distances and latent correlations for IPV chart creation

When creating IPV charts, you will work with "est". But you should always inspect the estimated models ("lav") to understand what is going on with your data! Use the lavaan functions (e.g. `lavaan::fitmeasures`, `lavaan::summary`, `lavaan::lavInspect`) for this purpose.

A more thorough introduction to the formatting of the objects representing model estimates can be found in section 1b. below.

### 1b. Read existing estimates

**Estimating the models yourself and reading in the estimates will take more effort than formatting the raw data and using `ipv_est()`. For this reason, it is not recommended.** On the other hand, it provides you with additional options during model estimation.

To use the chart functions, the model estimation results need an appropriate format. This is an example for the format used within the IPV package:
```{r}
self_confidence$tests$RSES
```
Note, that `factor` refers to an item pool, that was divided into subpools (`subfactor`s). In this case, `factor` refers to the Rosenberg Self-Esteem Scale, a test with two facets: Positive Self-Esteem (Ps), and Negative Self-Esteem (Ns), which was reversed here. As seen below, the same data structure applies on the global level, with `factor` referring to the overall self-confidence item pool, comprising the three tests (`subfactor`s) RSES, SMTQ, and DSSEI.  
```{r}
self_confidence$global
```
`cd` is short for center distance  
\begin{equation}
  cd_i = \frac{\lambda^2_{is}}{\lambda^2_{ig}} -1
\end{equation}  
while `mean_cd` is the mean center distance of the items of a facet or test. Furthermore, the matrix of latent correlations between `subfactor`s is given as a second item of the list. To see how the data is combined for nested cases, load the package and call the example object `self_confidence`.  
To spare you the task of creating this data structure by hand, I implemented two automated input pathways. You can either use excel files or the manual input function. In both cases, center distances are calculated automatically and the data is automatically checked for (obvious) errors. Negative center distances are always set to zero before mean center distances are calculated. Regardless of the input mode, you will need to provide:  

* the names of all latent variables and items  
* the factor loadings of the SEMs  
* the latent correlations between the factors within the SEMs.

#### ...using manual input functions
These functions allow you to reduce the manual work to a minimum. They are especially useful, when your SEM estimates are already in your R environment (e.g. because you read them from a .csv file). The functions `input_manual_nested()` and `input_manual_simple()` allow you to feed in factor loadings, item names, etc. variable by variable. The correct format is then generated automatically. Run `input_manual_process()` on the result, to automatically calculate center distances.  
This is an example, where all values have been put in individually for demonstration:

```{r}
mydata <- input_manual_simple(
test_name = "RSES",
facet_names = c("Ns", "Ps"),
items_per_facet = 5,
item_names = c(
  2, 5, 6, 8, 9,
  1, 3, 4, 7, 10),
test_loadings = c(
  .5806, .5907, .6179, .5899, .6559,
  .6005, .4932, .4476, .5033, .6431),
facet_loadings = c(
  .6484, .6011, .6988, .6426, .6914,
  .6422, .5835, .536, .5836, .6791),
correlation_matrix = matrix(
  data = c(1, .69,
           .69, 1),
  nrow = 2,
  ncol = 2))
mydata
input_manual_process(mydata)
```
For nested cases, use the function `input_manual_nested()`, and add the individual tests using `input_manual_simple()`. Then you can run `input_manual_processs()` as in the simple case. You can find a (lengthy) example [below](#nested).  
If any factor loading is below .1 or any center distance below 0, it is set to that value and a warning (or message) is displayed. IPV does not allow negative factor loadings, which is indicated by an error. In this case, recode your data appropriately.

#### ...using Excel files
Excel files have the advantage that you can simply copy and paste your SEM estimates into the spreadsheets and the input function of the IPV package (`input_excel()`) does the rest. The files need to be structured as in the example, that you can find here:
```{r, eval = FALSE}
system.file("extdata", "IPV_global.xlsx", package = "IPV", mustWork = TRUE)
system.file("extdata", "IPV_DSSEI.xlsx", package = "IPV", mustWork = TRUE)
system.file("extdata", "IPV_SMTQ.xlsx", package = "IPV", mustWork = TRUE)
system.file("extdata", "IPV_RSES.xlsx", package = "IPV", mustWork = TRUE)
```

As you can see, there is a file for each test, and a global file. You might want to use a copy as your template, so you can just fill in your values. Open a file to see how it works.  

On sheet 1 you need to provide the factor loadings from your SEM estimation results, on sheet 2 you need to provide the named and complete latent correlation matrix. On sheet 1, "factor" contains a single factor name and "factor_loading" the factor loadings of items on that factor (not squared). "subfactor" contains the names of grouped factors and "subfactor_loading" the factor loadings of items on these factors (not squared). "item" contains the item names. Therefore, each row contains the full information on the respective item.  
Read these excel sheets using input_excel. In the example:
```{r}
global <- system.file("extdata", "IPV_global.xlsx", package = "IPV", mustWork = TRUE)
tests <- c(system.file("extdata", "IPV_DSSEI.xlsx", package = "IPV", mustWork = TRUE),
           system.file("extdata", "IPV_SMTQ.xlsx", package = "IPV", mustWork = TRUE),
           system.file("extdata", "IPV_RSES.xlsx", package = "IPV", mustWork = TRUE))
mydata <- input_excel(global = global, tests = tests)
```

The data will be prepared automatically, including the calculation of center distances. If any factor loading is below .1 or any center distance below 0, it is set to that value and a warning or message is displayed. IPV does not allow negative factor loadings, which is indicated by an error. In this case, recode your data appropriately.

#### Mixing tests with and without facets
In nested charts, tests do not need to have facets. If you use input by excel, use `NA` instead of providing a file name.

```{r, eval=FALSE}
global <- system.file("extdata", "IPV_global.xlsx", package = "IPV", mustWork = TRUE)
tests <- c(system.file("extdata", "IPV_DSSEI.xlsx", package = "IPV", mustWork = TRUE),
           system.file("extdata", "IPV_SMTQ.xlsx", package = "IPV", mustWork = TRUE),
           NA)
mydata <- input_excel(global = global, tests = tests)
```

If you use manual input, do not provide data on facetless tests with `input_manual_simple()`. Any further treatment of facetless tests is handled automatically.


### 2.1. Create and save IPV charts

Use the chart functions (`item_chart`, `facet_chart`, `nested_chart`) to create an IPV chart from your data.

All three IPV chart types can be created by specifying `data = ` only:

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- item_chart(data = DSSEI)
mychart
```

I strongly recommend to use vector-based .pdf graphics output using the `file_name = ` argument. .pdf files can be zoomed and scaled indefinitely without loss of quality. If you need .png or .jpeg graphics output, use the `dpi = ` argument to find a balance between quality and file size. The file format provided to `file_name = ` will be used. By default, no file is saved. Saving manually is not recommended.

I recommend you to inspect the graphics file itself. To inspect your results within RStudio, always use the zoom pop-out of the Plots window, otherwise charts may be heavily distorted. 


### 2.2. Customize IPV charts

Although some graphical options are automatically optimized based on the data, there are many ways to optimize the charts' appearance (e.g. for print). For example you may use [color](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) to guide attention, or re-size elements of the chart for readability.

#### 2.2.1. Size of chart elements

Most graphical parameters are size parameters for single elements of the chart, all named `size_... = `,  `width_... = `, or `length_... = `. Those are pretty straightforward: linear scaling parameters defaulting to 1. That means, .5 will half the size and 2 will double it. For all chart types, there is also a global `size = ` parameter, scaling all elements of the chart at once. Use this parameter first, before you fine tune single elements.

#### 2.2.2. Scale output file

The parameters `file_width = ` and `file_length = ` determine, how large the .pdf file will be, measured in inches (1 in = 2.54 cm). The size of .png or .jpeg files in pixels is determined by multiplying the size in inches with the dots per inch parameter value (`dpi = `).

#### 2.2.3. Rotation

For all chart types, it is possible to rotate the whole chart, using `rotate_radians = ` or `rotate_degrees = `.

#### 2.2.4. Font

The font can be changed using the `font = ` parameter. I recommend [extrafont](https://cran.r-project.org/package=extrafont) for access to more fonts.

#### 2.2.5. Structural elements and data ink ratio

To reduce the visibility of structural elements, the `fade_... = ` parameters can be used (0 = "black", 100 = "white").

#### 2.2.6. Colour

For the use of colours and gray tones, I recommend [this guide](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). All charts functions have at least one colour parameter to highlight the data using colour.



#### 2.2.7. Special options for item charts

You can use different colors for every second item to increase readability of item charts:
```{r, eval=FALSE, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- item_chart(data = DSSEI,
                      color = "darkblue", color2 = "darkred",
                      fade_axes = 70, fade_grid_major = 50, fade_grid_minor = 92,
                      size = 1.3, length_items = 2.5, width_grid = .6, size_tick_label = .6,
                      length_ratio_items = 1, width_items = .9)
mychart
```

The `dodge = ` parameter allows long facet labels to dodge the rest of the chart horizontally:
```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", fig.show='hold', dev='png'}
x <- DSSEI
colnames(x$cors)[4] <- "Oachkatzlschwoaf"
rownames(x$cors)[4] <- "Oachkatzlschwoaf"
levels(x$cds$subfactor) <- c("Ab", "Pb", "Ph", "Oachkatzlschwoaf")
x$cds$subfactor[16:20] <- "Oachkatzlschwoaf"
mychart1 <- item_chart(data = x)
mychart2 <- item_chart(data = x, dodge = 7)
mychart1
mychart2
```
This works simultaneously for all labels. Labels at the top and bottom do not move, labels on the right and left move the most.

#### 2.2.8. Special options for facet charts

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- facet_chart(data = DSSEI)
mychart
```
As you can see in the output (and the message in the console), two parameter values (`subradius = ` , and `tick = ` ) have been generated automatically. These can be used to improve readability. 



For a simplistic version of the chart, the correlations can be omitted, by setting `cor_labels = FALSE`.
```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- facet_chart(data = DSSEI,
                      cor_labels = FALSE)
mychart
```


#### 2.2.9. Special options for nested charts

There are four important options specific to nested charts: the `relative_scaling = ` of the global and the nested level, the addition of `xarrows = ` to display correlation arrows between facets of different tests, the ability to `subrotate_... = ` each test individually, and the `cor_spacing = ` to display correlations between the tests. Due to the complexity one should not rely on default values too much:

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- nested_chart(data = self_confidence)
mychart
```
The radius of the facet circles (`subradius = ` parameter) has no meaning. It should be chosen large enough to make the facet labels and correlations readable. But it should also be small enough to avoid overlapping facet circles. The center distances (thick lines) should ominate the first impression.

The `relative_scaling = ` should be large enough to have the center distances on the global level shape the overall impression. But a large value for the `relative_scaling = ` makes the nested facet charts of each test small and possibly unreadable. Note, that the axis scaling within the nested facet charts is different to the global axis scaling by exactly the factor of `relative_scaling = ` , as can be seen from the axis tick marks (small dotted circles). In this particular case, the facet circles could be larger, including the font sizes within:
```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- nested_chart(data = self_confidence,
                        subradius = .5, size_facet_labels = 2, size_cor_labels_inner = 1.5)
mychart
```
(The dynamic default for `relative_scaling = ` adapted to the changes, because the test circles became larger, due to the changes to `subradius = ` .)

The addition of correlation arrows between facets of different tests is indicated by the IPV authors as sensible, when the correlation between these facets exceed the correlation between the respective tests. In the current example, this would result in three extra arrows, that can be added as follows:

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
sc_arrows <- data.frame(
  test1 = rep(NA, 3), facet1 = NA,
  test2 = NA, facet2 = NA,
  value = NA)
sc_arrows[1, ] <- c("DSSEI", "Ab", "RSES", "Ps", ".67")
sc_arrows[2, ] <- c("DSSEI", "Ab", "SMTQ", "Cs", ".81")
sc_arrows[3, ] <- c("SMTQ", "Ct", "RSES", "Ns", ".76")
sc_arrows

mychart <- nested_chart(data = self_confidence,
                        subradius = .5, size_facet_labels = 2, size_cor_labels_inner = 1.5,
                        xarrows = sc_arrows, show_xarrows = TRUE)
mychart
```

The column names of the data frame providing the data for the arrows need to match the example.

The arrows create a lot of overlap and make the chart look messy. This problem can be solved by rotating each of the nested facet charts, so the facets connected by arrows are oriented towards the center. Also the construct label should be moved out of harms way, as well as the test label of the SMTQ.

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- nested_chart(data = self_confidence,
                        subradius = .5, size_facet_labels = 2, size_cor_labels_inner = 1.5,
                        xarrows = sc_arrows, show_xarrows = TRUE,
                        subrotate_degrees = c(180, 270, 90), dist_construct_label = .7,
                        rotate_test_labels_degrees = c(0, 120, 0))
mychart
```

The `cor_spacing = ` refers to the ring around the nested facet charts for each test, in which the correlations between the tests are displayed. It should be large enough for the correlation labels, but not too large. If the correlations are omitted, this ring is also omitted:

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- nested_chart(data = self_confidence,
                        subradius = .5, size_facet_labels = 2, size_cor_labels_inner = 1.5,
                        xarrows = sc_arrows, show_xarrows = TRUE,
                        subrotate_degrees = c(180, 270, 90), dist_construct_label = .7,
                        rotate_test_labels_degrees = c(0, 120, 0),
                        cor_labels_tests = FALSE)
mychart
```
To get a printworthy result, let us change some `size_... = ` parameters and add some color. Color can be chosen for the global and the nested level independently. Furthermore, it might be better to increase the line thickness, so the colours get emphasized.

```{r, fig.width=10, fig.height=10, dpi=72, out.height="685px", out.width="685px", dev='png'}
mychart <- nested_chart(data = self_confidence,
                        subradius = .5, size_facet_labels = 2, size_cor_labels_inner = 1.5,
                        xarrows = sc_arrows, show_xarrows = TRUE,
                        subrotate_degrees = c(180, 270, 90), dist_construct_label = .7,
                        rotate_construct_label_degrees = -15,
                        rotate_test_labels_degrees = c(0, 120, 0),
                        color_global = "cyan4", color_nested = "darkblue",
                        size_construct_label = 1.3, size_test_labels = 1.2,
                        width_circles_inner = 1.5, width_circles = 1.5, width_axes_inner = 1.5, width_axes = 1.5)
mychart
```

### Appendix
#### manual input in nested cases - example {#nested}

Note that all values that are put in manually for presentation purposes here could be read from an arbitrarily formatted R object. Copying values manually from another source is error-prone and therefore not recommended.

```{r}
# first the global level
mydata <- input_manual_nested(
  construct_name = "Self-Confidence",
  test_names = c("DSSEI", "SMTQ", "RSES"),
  items_per_test = c(20, 14, 10),
  item_names = c(
     1,  5,  9, 13, 17, # DSSEI
     3,  7, 11, 15, 19, # DSSEI
    16,  4, 12,  8, 20, # DSSEI
     2,  6, 10, 14, 18, # DSSEI
    11, 13, 14,  1,  5,  6, # SMTQ
     3, 10, 12,  8, # SMTQ
     7,  2,  4,  9, # SMTQ
     1,  3,  4,  7, 10, # RSES
     2,  5,  6,  8,  9), # RSES
  construct_loadings = c(
    .5189, .6055, .618 , .4074, .4442,
    .5203, .2479, .529 , .554 , .5144,
    .3958, .5671, .5559, .4591, .4927,
    .3713, .5941, .4903, .5998, .6616,
    .4182, .2504, .4094, .3977, .5177, .4603,
    .3271, .261 , .3614, .4226,
    .2076, .3375, .5509, .3495,
    .5482, .4627, .4185, .4185, .5319,
    .4548, .4773, .4604, .4657, .4986),
  test_loadings = c(
    .5694, .6794, .6615, .4142, .4584, # DSSEI
    .5554, .2165, .5675, .5649, .4752, # DSSEI
    .443 , .6517, .6421, .545 , .5266, # DSSEI
    .302 , .6067, .5178, .5878, .6572, # DSSEI
    .4486, .3282, .4738, .4567, .5986, .5416, # SMTQ
    .3602, .2955, .3648, .4814, # SMTQ
    .2593, .4053, .61  , .4121, # SMTQ
    .6005, .4932, .4476, .5033, .6431, # RSES
    .5806, .5907, .6179, .5899, .6559), # RSES
  correlation_matrix = matrix(
    data = c(
      1 , .73, .62,
      .73, 1, .75,
      .62, .75, 1),
    nrow = 3,
    ncol = 3))

# then add tests individually
# test 1
mydata$tests$RSES <- input_manual_simple(
  test_name = "RSES",
  facet_names = c("Ns", "Ps"),
  items_per_facet = c(5, 5),
  item_names = c(
    2, 5, 6, 8,  9,
    1, 3, 4, 7, 10),
  test_loadings = c(
    .5806, .5907, .6179, .5899, .6559,
    .6005, .4932, .4476, .5033, .6431),
  facet_loadings = c(
    .6484, .6011, .6988, .6426, .6914,
    .6422, .5835, .536, .5836, .6791),
  correlation_matrix = matrix(
    data = c(
      1, .69,
      .69, 1),
    nrow = 2,
    ncol = 2))
# test 2
mydata$tests$DSSEI <- input_manual_simple(
  test_name = "DSSEI",
  facet_names = c("Ab", "Pb", "Ph", "So"),
  items_per_facet = 5,
  item_names = c(
    2, 6, 10, 14, 18,
    16, 4, 12, 8, 20,
    3, 7, 11, 15, 19,
    1, 5, 9, 13, 17),
  test_loadings = c(
    .302 , .6067, .5178, .5878, .6572,
    .443 , .6517, .6421, .545 , .5266,
    .5554, .2165, .5675, .5649, .4752,
    .5694, .6794, .6615, .4142, .4584),
  facet_loadings = c(
    .3347, .6537, .6078, .684 , .735 ,
    .6861, .8746, .7982, .7521, .6794,
    .7947, .3737, .819 , .7099, .5785,
    .7293, .8284, .7892, .3101, .4384),
  correlation_matrix = matrix(
    data = c(
      1, .49, .66, .76,
      .49, 1, .37, .54,
      .66, .37, 1, .53,
      .76, .54, .53, 1),
    nrow = 4,
    ncol = 4))
# test 3
mydata$tests$SMTQ <- input_manual_simple(
  test_name = "SMTQ",
  facet_names = c("Cf", "Cs", "Ct"),
  items_per_facet = c(6, 4, 4),
  item_names = c(
    11, 13, 14, 1, 5, 6,
    3, 10, 12, 8,
    7, 2, 4, 9),
  test_loadings = c(
    .4486, .3282, .4738, .4567, .5986, .5416,
    .3602, .2955, .3648, .4814,
    .2593, .4053, .61  , .4121),
  facet_loadings = c(
    .4995, .3843, .5399, .4562, .6174, .6265,
    .4601, .3766, .4744, .5255,
    .3546, .5038, .7429, .4342),
  correlation_matrix = matrix(
    data = c(
      1, .71, .62,
      .71, 1, .59,
      .62, .59,	1),
    nrow = 3,
    ncol = 3))

# finally process (as in a simple case)
my_processed_data <- input_manual_process(mydata)
my_processed_data
```
