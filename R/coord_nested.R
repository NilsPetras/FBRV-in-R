#'Coord Nested
#'
#'Generates coordinates for a nested chart and all other charts.
#'
#'@param data list generated by \code{\link{input_excel}}, or by hand,
#'  containing formatted data.
#' @param subradius integer; same unit as center distances; radius of the
#'   circles representing facets; use to avoid circle overlap and optimize
#'   appearance; if 0 (default) a value is chosen automatically.
#'@param tick numeric; axis tick position; if 0 (default) a value is chosen
#'  automatically.
#'@param rotate_radians integer; radian angle to rotate the chart
#'  counter-clockwise by; use fractions of pi (e.g. pi/2 = 90 degrees).
#'@param rotate_degrees integer; angle in degrees to rotate the chart
#'  counter-clockwise by.
#'@param subrotate_radians integer; radian angle or vector of radian angles to
#'  rotate the nested facet charts counter-clockwise by; use fractions of pi
#'  (e.g. pi/2 = 90 degrees).
#'@param subrotate_degrees integer; angle in degrees or vector of angles in
#'  degrees to rotate the nested facet charts counter-clockwise by.
#'@param rotate_title_radians integer; radian angle to rotate the global label
#'  counter-clockwise by; use fractions of pi (e.g. pi/2 = 90 degrees).
#'@param rotate_title_degrees integer; angle in degrees to rotate the global
#'  label counter-clockwise by.
#'@param prepare_item_charts logical; if \code{TRUE}, generates coordinates for
#'  item charts for all factors by calling \code{\link{coord_items}}.
#'@param correlations logical; if \code{TRUE}, generates coordinates for latent
#'  correlations between tests and sets up a ring to draw them in. If
#'  \code{FALSE}, the ring and the correlations are omitted, simplifying the
#'  chart significantly.
#'@param cor_spacing integer; if \code{correlations = TRUE}: width of the ring
#'  the latent correlations between tests are drawn in; if 0 (default) a value
#'  is chosen automatically.
#'@param relative_scaling integer; relative size of the global chart compared to
#'  the nested facet charts; if 0 (default), a value is chosen automatically.
#'@param xarrows data frame containing information about additional correlation
#'  arrows between facets of different tests; see examples.
#'
#'@details Use this function in conjunction with \code{\link{plot_nested}} for
#'  nested models.
#'
#'  Use \code{\link{nested_chart}} to create the chart in a single step.
#'
#'  The following changes to the chart appearance are made using this function,
#'  not \code{\link{plot_nested}}: \itemize{ \item overall rotation \item
#'  rotation of nested charts \item title repositioning \item circle radius
#'  \item relative scaling \item size of space for correlations }
#'
#'  This function also provides coordinates for facet charts and item charts (if
#'  \code{prepare_item_charts = TRUE}) You can use it in conjunction with
#'  \code{\link{plot_facets}} or \code{\link{plot_items}}.
#'
#'  If you set \code{subrotate} to a single value, all nested facet charts will
#'  be rotated by the same amount. If you use a vector of values, the nested
#'  facet charts will be rotated one by one by the values from that vector.
#'
#'  Increase \code{relative_scaling} to avoid circle overlap. Decrease it to
#'  make small chart objects more visible.
#'
#'  \code{correlations} and \code{cor_spacing} add larger circles around the
#'  nested facet charts, but do not change these facet charts.
#'
#'
#'@return List containing coordinates of chart objects.
#'
#'@seealso \code{\link{plot_nested}} \code{\link{nested_chart}}
#'
#' @examples
#' # # creating nested charts is a two step process, using this function and
#' # # plot_nested:
#' # coord <- coord_nested(self_confidence, subradius = .6)
#' # sc_nested <- plot_nested(coord, filename = "sc_nested")
#' # sc_nested
#' #
#' # # adding xarrows
#' # sc_arrows <- data.frame(test1 = rep(NA, 3),
#' #                          facet1 = NA,
#' #                         test2 = NA,
#' #                          facet2 = NA,
#' #                         value = NA)
#' # sc_arrows[1, ] <- c("DSSEI", "Ab", "RSES", "Ps", ".67")
#' # sc_arrows[2, ] <- c("DSSEI", "Ab", "SMTQ", "Cs", ".81")
#' # sc_arrows[3, ] <- c("SMTQ", "Ct", "RSES", "Ns", ".76")
#' # coord <- coord_nested(self_confidence,
#'#                        subradius = .6,
#'#                        xarrows = sc_arrows)
#' # sc_nested <- plot_nested(coord, filename = "sc_nested", show_xarrows = TRUE)
#' # sc_nested
#'#
#' # # rotating the nested facet charts one by one
#' # coord <- coord_nested(self_confidence,
#'#                        subradius = .6,
#'#                        subrotate_radians = c(0, pi / 2, 0))
#'#  sc_nested <- plot_nested(coord, filename = "sc_nested")
#'#  sc_nested
coord_nested <- function (
  data,
  subradius = 0,
  tick = 0,
  rotate_radians = 0,
  rotate_degrees = 0,
  subrotate_radians = 0,
  subrotate_degrees = 0,
  rotate_title_radians = 0,
  rotate_title_degrees = 0,
  prepare_item_charts = FALSE,
  correlations = TRUE,
  cor_spacing = 0,
  relative_scaling = 0,
  xarrows = NULL) {


  # helper variables -----------------------------------------------------------

  # total subrotation value in radians
  subrotate <- subrotate_radians + subrotate_degrees * pi / 180


  # listwise calculation for single factors ------------------------------------

  # with one value for all subrotations
  if (length(subrotate) == 1) {
    factorcoords <- lapply(data$tests,
                           coord_facets,
                           subradius = subradius,
                           rotate_radians = subrotate)
    names(factorcoords) <- names(data$tests)
  }
  if (length(subrotate) == 1 & prepare_item_charts == TRUE) {
    itemcoords <- lapply(data$tests,
                         coord_items,
                         rotate_radians = subrotate)
    names(itemcoords) <- names(data$tests)
  }

  # with a vector of values for subrotations
  if (length(subrotate) == length(data$tests)) {
    factorcoords <- list()
    for (i in 1:length(data$tests)) {
      factorcoords[[i]] <- coord_facets(data$tests[[i]],
                                        subradius = subradius,
                                        rotate_radians = subrotate[i])
    }
    names(factorcoords) <- names(data$tests)
  }
  if (length(subrotate) == length(data$tests) & prepare_item_charts == TRUE) {
    itemcoords <- list()
    for (i in 1:length(data$tests)) {
      itemcoords[[i]] <- coord_items(data$tests[[i]],
                                     rotate_radians = subrotate[i])
    }
    names(itemcoords) <- names(data$tests)
  }


  # helper variables -----------------------------------------------------------

  # names of factors
  nam <- colnames(data$g$cors)

  # total rotation value in radians
  rotate <- rotate_radians + rotate_degrees * pi / 180

  # total title rotation value in radians
  rotate_title <- rotate_title_radians + rotate_title_degrees * pi / 180

  # number of factors
  cplx <- length(colnames(data$g$cors))

  # retrieving the size of the factor circles from the coord_facets output
  getcircsize <- function (x) {
    polcircs <- get(x = "p_circs", envir = as.environment(x))
    polcircs <- polcircs[1, "radius"]
  }
  circsize <- unlist(lapply(factorcoords, getcircsize))
  if (cor_spacing == 0) cor_spacing <- .15 * max(circsize)
  circsize <- circsize + correlations * cor_spacing

  # global mean center distances
  g_cds <- data.frame(lapply(split(data$g$cds, data$g$cds$subfactor),
                             function (x) y <- x$mean_cd[1]))
  g_cds <- t(g_cds)
  g_cds <- data.frame(g_cds)

  # relative scaling
  rs <- relative_scaling
  if (rs == 0) {
    rs <- mean(circsize) / mean(g_cds$g_cds) * 3 * (cplx + 3) / (20 - cplx / 2)
  }

  # default axis tick
  if (tick == 0){
    tick <- signif(
      max(.15 * max(data$g$cds$mean_cd),
          .3 * min(data$g$cds$mean_cd)) *
        rs ^ .25,
      1)
    if (rs < 3 * (cplx + 3) / 200){
      tick <- signif(tick * rs, 1)
    }
    if (rs > 1.5 * (cplx + 3)) {
      tick <- signif(10 * tick / rs, 1)
    }
  }


  # global chart objects -------------------------------------------------------

  ## circles ------------------------

  # polar coordinates of factor circles
  p_circs <- data.frame(phi = rep(NA, cplx + 1),
                        rho = 0,
                        radius = NA)
  row.names(p_circs) <- c(levels(data$g$cds$factor), nam)
  p_circs[names(circsize), "radius"] <- circsize
  p_circs$radius[1] <- max(g_cds[nam, ] * rs + circsize[nam] * 2)
  p_circs[nam, "rho"] <- c(g_cds[nam, ] * rs + circsize[nam])
  p_circs$phi <- c(0, 2 * pi / cplx * c(1:cplx)) + rotate
  p_circs$phi[p_circs$phi > 2 * pi] <-
    p_circs$phi[p_circs$phi > 2 * pi] - 2 * pi

  # cartesian coordinates
  # x=cos(phi)*rho
  # y=sin(phi)*rho
  c_circs <- p_circs
  # rounded values to decrease display length in console
  c_circs[ ,1] <- round(cos(p_circs$phi) * p_circs$rho, digits = 7)
  c_circs[ ,2] <- round(sin(p_circs$phi) * p_circs$rho, digits = 7)
  names(c_circs) <- c("x", "y", "radius")
  row.names(c_circs)[1] <- ""

  # polar coordinates of factor correlation rings
  if(correlations == T) {
    p_ring <- data.frame(phi = rep(NA, cplx + 1),
                         rho = NA,
                         radius = NA)
    row.names(p_ring) <- c(levels(data$g$cds$factor), nam)
    p_ring[names(circsize), "radius"] <- circsize - correlations * cor_spacing
    p_ring[nam, "rho"] <- c(g_cds[nam, ] * rs + circsize[nam])
    p_ring$phi <- c(0, 2 * pi / cplx * c(1:cplx)) + rotate
    p_ring$rho[-1] <- p_ring$rho[-1]
    p_ring <- p_ring[-1, ]
    p_ring <- p_ring
  } else p_ring <- NULL

  # cartesian coordinates
  if(correlations == T) {
    c_ring <- p_ring
    c_ring[,1] <- round(cos(p_ring$phi) * p_ring$rho, digits = 7)
    c_ring[,2] <- round(sin(p_ring$phi) * p_ring$rho, digits = 7)
    names(c_ring) <- c("x", "y", "radius")
  } else c_ring <- NULL


  ## axes ---------------------------

  # polar coordinates of global radial axes
  # axes are split into two segments by the test circles:
  # one from the origin (rho0) to the inner edge of the test circles (rho1),
  # the center distance
  # one from the outer edge of the test circles (rho2) to the edge of
  # the main circle (rho3)
  p_axes <- data.frame(rho0 = rep(0, cplx),
                       rho1 = NA,
                       rho2 = NA,
                       rho3 = NA,
                       phi = NA)
  row.names(p_axes) <- nam
  p_axes$phi <- utils::tail(p_circs$phi, cplx)
  p_axes$rho1 <- utils::tail(p_circs$rho, cplx) -
                  utils::tail(p_circs$radius, cplx)
  p_axes$rho2 <- p_axes$rho1 + 2 * utils::tail(p_circs$radius, cplx)
  p_axes$rho3 <- rep(p_circs$radius[1])

  # cartesian coordinates
  c_axes <- data.frame(x0 = rep(NA, cplx), y0 = NA,
                       x1 = NA, y1 = NA,
                       x2 = NA, y2 = NA,
                       x3 = NA, y3 = NA)
  row.names(c_axes) <- nam
  c_axes$x0 <- round(cos(p_axes$phi) * p_axes$rho0, digits = 7)
  c_axes$x1 <- round(cos(p_axes$phi) * p_axes$rho1, digits = 7)
  c_axes$x2 <- round(cos(p_axes$phi) * p_axes$rho2, digits = 7)
  c_axes$x3 <- round(cos(p_axes$phi) * p_axes$rho3, digits = 7)
  c_axes$y0 <- round(sin(p_axes$phi) * p_axes$rho0, digits = 7)
  c_axes$y1 <- round(sin(p_axes$phi) * p_axes$rho1, digits = 7)
  c_axes$y2 <- round(sin(p_axes$phi) * p_axes$rho2, digits = 7)
  c_axes$y3 <- round(sin(p_axes$phi) * p_axes$rho3, digits = 7)

  # coordinates of axis tick label
  # sets the tick to a rounded half minimum mean center distance and can be
  # overwritten manually
  # the axis tick label is displayed between the rightmost axis and the next one
  # counter-clockwise
  axis_tick <- data.frame(rho = tick, phi = NA, x = NA, y = NA)
  axis_tick$phi <- min(p_circs$phi) + pi / cplx
  axis_tick$x <- round(cos(axis_tick$phi) * axis_tick$rho, digits = 7)
  axis_tick$y <- round(sin(axis_tick$phi) * axis_tick$rho, digits = 7)


  ## title --------------------------

  # coordinates of overall general factor name
  # the factor label automatically shows next to the lowest mean center distance
  # (counter-clockwise)
  # the factor label shows at 2/3 of the distance from the origin to the edge of
  # the main circle
  title <- data.frame(
    x = NA,
    y = NA,
    label = row.names(p_circs)[1],
    phi=NA,
    rho=NA)
  title$phi <- p_circs[which.min(p_circs$radius), "phi"] +
                pi / cplx + rotate_title
  title$rho <- (1 - 2 / (1 + cplx)) * max(p_circs$radius)
  title$x <- round(cos(title$phi) * title$rho, digits = 7)
  title$y <- round(sin(title$phi) * title$rho, digits = 7)


  ## correlations -------------------

  # coordinates of latent test correlation labels
  # each correlation label appears twice: once in each facet's circle
  # n = 2 * number of correlations
  n <- cplx * (cplx - 1)
  cors <- data.frame(x = rep(NA, n),
                     y = NA,
                     V1 = NA,
                     V2 = NA,
                     label = NA,
                     xnew = NA,
                     ynew = NA)

  # all pairs of subfactors are covered twice, once in every order, excluding
  # self-pairing
  a <- row.names(data$g$cors)
  a <- c(a, a[1])
  b <- NULL
  for (k in 1:cplx) {
    b <- c(b, a[-c(1, cplx + 1)])
    a <- a[-1]
    a <- c(a, a[1])
  }
  cors$V1 <- b
  cors$V2 <- unlist(lapply(row.names(data$g$cors), rep, times = cplx - 1))

  # correlation values
  for (k in 1:n) {
    cors$label[k] <- data$g$cors[cors$V1[k], cors$V2[k]]
  }
  cors$label <- as.character(cors$label)
  cors$label[cors$label != 1 && cors$label != 0] <- substr(cors$label, 2, 4)

  # label coordinates
  cors$x <- c_circs[cors$V2, "x"]
  cors$y <- c_circs[cors$V2, "y"]

  # scattered as list in the general direction of the partner variable
  scatter <- rep(seq(from = (-pi + 2 * pi / cplx) / 2,
                     to = (pi - 2 * pi / cplx) / 2,
                     by = (pi - 2 * pi / cplx) / (cplx - 2)),
                 cplx)
  rho <- p_circs[cors$V2, "radius"]
  phi <- p_circs[cors$V2, "phi"]
  cors$xnew <- cors$x +
    round(cos(phi + pi + scatter), digits = 7) *
    (rho - correlations * .5 * cor_spacing)
  cors$ynew <- cors$y +
    round(sin(phi + pi + scatter), digits = 7) *
    (rho - correlations * .5 * cor_spacing)
  cors$x <- cors$xnew
  cors$y <- cors$ynew
  cors[6:7] <- list(NULL)


  # nested chart objects -------------------------------------------------------

  # these objects are put into a list ('nested') next to the
  # data frames containing the global chart objects

  ## shifted facet charts -----------

  subcircles <- list()
  for(i in 1:cplx) {
    subcircles[[nam[i]]] <- shift_factor(factorcoords[[nam[i]]],
                                         c_circs[nam[i], "x"],
                                         c_circs[nam[i], "y"])
  }


  # the coordinates of the following nested chart objects
  # get bunched together across factors
  nested <- list(circles = NULL,
                 axes = NULL,
                 title = NULL,
                 cors = NULL)


  ## chart objects ------------------

  # circles
  for (i in 1:cplx) nested$circles[[nam[i]]] <- subcircles[[c(i, 1)]]
  nested$circles <- lapply(nested$circles, utils::tail, n = -1)
  nested$circles <- do.call("rbind", nested$circles)
  # cutting test names from labels
  nested$circles$label <- substr(
    row.names(nested$circles),
    unlist(gregexpr(pattern = "\\.", row.names(nested$circles))) + 1,
    nchar(row.names(nested$circles)))

  # axes
  for (i in 1:cplx) nested$axes[[nam[i]]] <- subcircles[[c(i, 2)]]
  nested$axes <- do.call("rbind", nested$axes)

  # titles
  for (i in 1:cplx) nested$title[[nam[i]]] <- subcircles[[c(i, 3)]]
  nested$title <- do.call("rbind", nested$title)

  # correlations
  for (i in 1:cplx) nested$cors[[nam[i]]] <- subcircles[[c(i,4)]]
  nested$cors <- do.call("rbind", nested$cors)


  # extra arrows ---------------------------------------------------------------

  ## arrows -------------------------

  if (!is.null(xarrows)) {
    # n = number of arrows
    n <- dim(xarrows)[1]
    arrows <- data.frame(x1 = rep(NA, n),
                         x2 = NA,
                         y1 = NA,
                         y2 = NA,
                         label = NA,
                         xlabel = NA,
                         ylabel = NA)
    arrows$label <- xarrows$value
    # note: facet circles are named as 'factor.facet' within nested$circles
    arrows$x1 <- nested$circles[paste(xarrows$test1,
                                      xarrows$facet1,
                                      sep = "."),
                                "x"]
    arrows$y1 <- nested$circles[paste(xarrows$test1,
                                      xarrows$facet1,
                                      sep = "."),
                                "y"]
    arrows$x2 <- nested$circles[paste(xarrows$test2,
                                      xarrows$facet2,
                                      sep = "."),
                                "x"]
    arrows$y2 <- nested$circles[paste(xarrows$test2,
                                      xarrows$facet2,
                                      sep = "."),
                                "y"]


    ## labels -----------------------

    # labels are placed on the intersection between the arrow
    # and an imaginary line halfway between the test circles
    # to avoid overlap with any other chart objects
    # the calculations used to achieve this are documented elsewhere,
    # due to being quite complicated

    # x- and y-distances between the centers of the big and
    # the small circles involved
    xdist_big <- NULL
    ydist_big <- NULL
    for (i in 1:n) {
      xdist_big[i] <- c_circs[xarrows$test2[i], "x"] -
        c_circs[xarrows$test1[i], "x"]
      ydist_big[i] <- c_circs[xarrows$test2[i], "y"] -
        c_circs[xarrows$test1[i], "y"]
    }
    xdist_small <- arrows$x2 - arrows$x1
    ydist_small <- arrows$y2 - arrows$y1
    # total distances between the centers of the big and
    # the small circles involved
    dist_big <- sqrt(xdist_big ^ 2 + ydist_big ^ 2)
    dist_small <- sqrt(xdist_small ^ 2 + ydist_small ^ 2)
    # points halfway between the big circles
    halfwaypoint <- data.frame(x = rep(NA, n), y = NA)
    for (i in 1:n) {
      halfwaypoint$x[i] <- (c_circs[xarrows$test1[i], "x"] +
                              c_circs[xarrows$test2[i], "x"]) / 2 +
        xdist_big[i] / dist_big[i] /
        2 * (c_circs[xarrows$test1[i], "radius"] -
               c_circs[xarrows$test2[i], "radius"])
      halfwaypoint$y[i] <- (c_circs[xarrows$test1[i], "y"] +
                              c_circs[xarrows$test2[i], "y"]) / 2 +
        ydist_big[i] / dist_big[i] /
        2 * (c_circs[xarrows$test1[i], "radius"] -
               c_circs[xarrows$test2[i], "radius"])
    }
    # placing the labels alongside the arrow on their final positions
    d <- NULL
    for(i in 1:n){
      d[i] <- dist_small[i] *
        (((arrows$x1[i] - halfwaypoint$x[i]) * -xdist_big[i]) -
           ((arrows$y1[i] - halfwaypoint$y[i]) * ydist_big[i])) /
        (ydist_small[i] * ydist_big[i] - xdist_small[i] * -xdist_big[i])
    }
    arrows$xlabel <- arrows$x1 + d / dist_small * xdist_small
    arrows$ylabel <- arrows$y1 + d / dist_small * ydist_small

    # letting the correlation labels dodge their arrow by .1 sideways
    # to avoid overlap
    arrows$xlabel <- arrows$xlabel + .1 / dist_small * ydist_small
    arrows$ylabel <- arrows$ylabel + .1 / dist_small * -xdist_small


    ## arrows -----------------------

    # shifting arrow ends from center to edge of facet circles
    arrows$x1new <- arrows$x1 + subradius / dist_small * xdist_small
    arrows$x2new <- arrows$x2 + subradius / dist_small * -xdist_small
    arrows$y1new <- arrows$y1 + subradius / dist_small * ydist_small
    arrows$y2new <- arrows$y2 + subradius / dist_small * -ydist_small
    arrows$x1 <- arrows$x1new
    arrows$x2 <- arrows$x2new
    arrows$y1 <- arrows$y1new
    arrows$y2 <- arrows$y2new

    arrows[8:11] <- list(NULL)
    rm(n)
  } else arrows <- NULL

  rm(nam,cplx)


  # return ---------------------------------------------------------------------

  # list of lists of dataframes containing the coordinates of the chart objects
  # the first element ('factor') is a list of the lists created by coord_facets
  # for facet charts
  # the second element ('global') is a list containing the dataframes with
  # coordinates for the nested chart
  # the third optional element ('items') is a list of the lists created by
  # coord_items for item charts
  global <- list(p_circs     = p_circs,
                 c_circs     = c_circs,
                 p_ring      = p_ring,
                 c_ring      = c_ring,
                 p_axes      = p_axes,
                 c_axes      = c_axes,
                 axis_tick   = axis_tick,
                 title       = title,
                 cors        = cors,
                 nested      = nested,
                 rs          = rs,
                 cor_spacing = cor_spacing,
                 arrows      = arrows)
  coord <- list(factor = factorcoords,
                global = global)
  if (prepare_item_charts == T) coord$items <- itemcoords

  return(coord)
}
