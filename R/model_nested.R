#' Model Nested
#'
#' This function generates the coordinates for a nested plot and all other plots.
#'
#' @param data list generated by \code{\link{input_excel}} containing formatted data.
#' @param subradius integer; radius of the circles representing facets (same unit as center distances).
#' @param rotate integer; radian angle to rotate the plot counter-clockwise by (between 0 and 2*pi).
#' @param subrotate integer; radian angle or vector of radian angles to rotate the nested plots counter-clockwise by (between 0 and 2*pi).
#' @param rotate_title integer; radian angle to rotate the overall general factor label counter-clockwise by (between 0 and 2*pi).
#' @param items logical; if TRUE, generates the coordinates for item plots for all factors using \code{\link{model_items}}.
#' @param cors logical; if TRUE, generates coordinates for latent correlations between factors and sets up a ring to plot them in.
#' @param cor_spacing integer; width of the ring the latent correlations between factors are plotted in; defaults to 0.4.
#' @param relative_scaling integer; relative size of the global to the nested plots; defaults to 3.
#' @param extra_arrows a data frame containing information about additional correlation arrows between facets of different factors; see examples.
#'
#' @details Use this function to prepare for \code{\link{plot_nested}}
#' using data you read from an excel file with \code{\link{input_excel}}.
#' You can also create \code{data} yourself, but \code{data} needs the same structure as if
#' generated by \code{\link{input_excel}}.
#' This function can also provide data for facet plots and item plots
#' you can create using \code{\link{plot_facets}} and \code{\link{plot_items}}.
#' The \code{subrotate} argument can be a single value. In this case, all nested plots will be rotated in the same way.
#' It can also be a vector of values of the same length as the number of nested plots within the global plot. In this
#' case, every nested plot will be rotated by its specific value given in the vector.
#' Increase the value of the \code{relative_scaling} argument to avoid circle overlap. Decrease it to make small circles
#' more visible.
#' The \code{cor_spacing} argument increases the size of the nested plot's circles, keeping the scale of its inner parts as is.
#'
#'
#' @return A list of lists of dataframes containing the coordinates of the plot objects.
#'
#' @seealso \code{\link{plot_nested}}
#'
#' @examples
#' # creating plots is a two step process, using model_ and plot_ functions:
#' coord <- model_nested(self_confidence,subradius = .6)
#' sc_plot <- plot_nested(coord,filename = "self_confidence_nested")
#'
#' # adding extra arrows
#' sc_arrows <- data.frame(V1_factor=rep(NA,3),
#'                         V1_subfactor=rep(NA,3),
#'                         V2_factor=rep(NA,3),
#'                         V2_subfactor=rep(NA,3),
#'                         value=rep(NA,3))
#' sc_arrows[1,] <- c("DSSEI","Ab","RSES","Ps",".67")
#' sc_arrows[2,] <- c("DSSEI","Ab","SMTQ","Cs",".81")
#' sc_arrows[3,] <- c("SMTQ","Ct","RSES","Ns",".76")
#' coord <- model_nested(self_confidence,subradius = .6,extra_arrows = sc_arrows)
#' sc_plot <- plot_nested(coord,filename = "self_confidence_nested",extra_arrows = TRUE)
#'
#' # rotating the nested facet plots one by one
#' coord <- model_nested(self_confidence,subradius = .6,subrotate = c(0,pi/2,0))
#' sc_plot <- plot_nested(coord,filename = "self_confidence_nested")
#'
#' @export
model_nested <- function(data,subradius,
                      rotate=0,subrotate=0,rotate_title=0,
                      items=FALSE,cors=TRUE,cor_spacing=.4,relative_scaling=3,extra_arrows=NULL){


    ## listwise calculation for single factors using mode_facets and model_items

  # with one value for all subrotations (lapply)
    if(length(subrotate)==1){
      factorcoors <- lapply(X = data$factors,FUN = model_facets,subradius=subradius,rotate=subrotate)
      names(factorcoors) <- names(data$factors)
    }
    if(length(subrotate)==1 & items==TRUE){
      itemcoors <- lapply(data$factors,model_items,rotate=subrotate)
      names(itemcoors) <- names(data$factors)
    }
  # with a vector of values for subrotations (for-loop)
  if(length(subrotate)==length(data$factors)){
    factorcoors <- list()
    for(i in 1:length(data$factors)){
      factorcoors[[i]] <- model_facets(data$factors[[i]],subradius=subradius,rotate=subrotate[i])
    }
    names(factorcoors) <- names(data$factors)
  }
  if(length(subrotate)==length(data$factors) & items==TRUE){
    itemcoors <- list()
    for(i in 1:length(data$factors)){
      itemcoors[[i]] <- model_items(data$factors[[i]],rotate=subrotate[i])
    }
    names(itemcoors) <- names(data$factors)
  }


    ## helper variables

  # names of factors
  nam <- levels(data$global$center_distances$subfactor)

  # number of factors
  cplx <- data$global$parameters$complexity

  # retrieving the size of the factor circles from the model_facets output
  getcircsize <- function(x){
    polcircs <- get(x = "pol_circles",envir = as.environment(x))
    polcircs <- polcircs[1,"radius"]
  }
  circsize <- unlist(lapply(factorcoors,getcircsize))
  circsize <- circsize+cors*cor_spacing

  # global mean center distances
  global_center_distances <- data.frame(lapply(split(data$global$center_distances,data$global$center_distances$subfactor),function(x)y <- x$mean_center_distance[1]))
  global_center_distances <- t(global_center_distances)
  global_center_distances <- data.frame(global_center_distances)


    ## coordinates of global plot objects

  # polar coordinates of factor circles
    # the main circle is centered on the origin
    # the main circle's radius is set so it touches the furthest circle on the outside
    # the coordinates position the centers of the circles
    # note that the factor circles differ in center distance AND size
    # factor circle size depends on the size of the factor correlation ring
  pol_circles <- data.frame(phi=rep(NA,cplx+1),rho=rep(0,cplx+1),radius=rep(NA,cplx+1))
  row.names(pol_circles) <- c(levels(data$global$center_distances$factor),nam)
  pol_circles[names(circsize),"radius"] <- circsize
  pol_circles$radius[1] <- max(global_center_distances[nam,]*relative_scaling+circsize[nam]*2)
  pol_circles[nam,"rho"] <- c(global_center_distances[nam,]*relative_scaling+circsize[nam])
  pol_circles$phi <- c(0,2*pi/cplx*c(1:cplx))+rotate
  pol_circles$rho[-1] <- pol_circles$rho[-1]

  # cartesian coordinates of factor circles
    # x=cos(phi)*rho
    # y=sin(phi)*rho
  cart_circles <- pol_circles
  cart_circles[,1] <- round(cos(pol_circles$phi) * pol_circles$rho, digits = 7)
  cart_circles[,2] <- round(sin(pol_circles$phi) * pol_circles$rho, digits = 7)
  names(cart_circles) <- c("x","y","radius")
  row.names(cart_circles)[1] <- ""

  # polar coordinates of inner circle marking the factor correlation ring
  if(cors==T){
    pol_inner_ring <- data.frame(phi=rep(NA,cplx+1),rho=rep(NA,cplx+1),radius=rep(NA,cplx+1))
    row.names(pol_inner_ring) <- c(levels(data$global$center_distances$factor),nam)
    pol_inner_ring[names(circsize),"radius"] <- circsize-cors*cor_spacing
    pol_inner_ring[nam,"rho"] <- c(global_center_distances[nam,]*relative_scaling+circsize[nam])
    pol_inner_ring$phi <- c(0,2*pi/cplx*c(1:cplx))+rotate
    pol_inner_ring$rho[-1] <- pol_inner_ring$rho[-1]
    pol_inner_ring <- pol_inner_ring[-1,]
    pol_inner_ring <- pol_inner_ring
  }
  else pol_inner_ring <- NULL

  # cartesian coordinates of inner circle marking the factor correlation ring
  if(cors==T){
    cart_inner_ring <- pol_inner_ring
    cart_inner_ring[,1] <- round(cos(pol_inner_ring$phi) * pol_inner_ring$rho, digits = 7)
    cart_inner_ring[,2] <- round(sin(pol_inner_ring$phi) * pol_inner_ring$rho, digits = 7)
    names(cart_inner_ring) <- c("x","y","radius")
  }
  else cart_inner_ring <- NULL

  # polar coordinates of global axes
    # inner (rho1) and outer (rho2) intersection of axes and circles
    # intersection of axes and main circle (rho3)
  pol_axes <- data.frame(rho0=rep(0,cplx),rho1=rep(NA,cplx),rho2=rep(NA,cplx),rho3=rep(NA,cplx),phi=rep(NA,cplx))
  row.names(pol_axes) <- nam
  pol_axes$phi <- utils::tail(pol_circles$phi,cplx)
  pol_axes$rho1 <- utils::tail(pol_circles$rho,cplx)-utils::tail(pol_circles$radius,cplx)
  pol_axes$rho2 <- pol_axes$rho1 + 2 * utils::tail(pol_circles$radius,cplx)
  pol_axes$rho3 <- rep(pol_circles$radius[1])

  # cartesian coordinates of global axes
  cart_axes <- data.frame(x0=rep(NA,cplx),y0=rep(NA,cplx),x1=rep(NA,cplx),y1=rep(NA,cplx),
                          x2=rep(NA,cplx),y2=rep(NA,cplx),x3=rep(NA,cplx),y3=rep(NA,cplx))
  row.names(cart_axes) <- nam
  cart_axes$x0 <- round(cos(pol_axes$phi) * pol_axes$rho0, digits = 7)
  cart_axes$x1 <- round(cos(pol_axes$phi) * pol_axes$rho1, digits = 7)
  cart_axes$x2 <- round(cos(pol_axes$phi) * pol_axes$rho2, digits = 7)
  cart_axes$x3 <- round(cos(pol_axes$phi) * pol_axes$rho3, digits = 7)
  cart_axes$y0 <- round(sin(pol_axes$phi) * pol_axes$rho0, digits = 7)
  cart_axes$y1 <- round(sin(pol_axes$phi) * pol_axes$rho1, digits = 7)
  cart_axes$y2 <- round(sin(pol_axes$phi) * pol_axes$rho2, digits = 7)
  cart_axes$y3 <- round(sin(pol_axes$phi) * pol_axes$rho3, digits = 7)

  # coordinates of global axis tick label
    # this is only a template and sets the axis tick to 1
    # the actual tick is defined in the plot function by multiplying x and y with the tick value (defaults to 0.1)
  axis_tick <- data.frame(rho = 1, phi = NA, x = NA, y = NA)
  axis_tick$phi <- min(pol_axes$phi %% (2*pi)) + pi / cplx
  axis_tick$x <- round(cos(axis_tick$phi) * axis_tick$rho, digits = 7)
  axis_tick$y <- round(sin(axis_tick$phi) * axis_tick$rho, digits = 7)

  # coordinates of overall general factor name
    # the factor label automatically shows next to the lowest mean center distance (counter-clockwise)
    # the factor label shows at 2/3 of the distance from the origin to the edge of the main circle
  factor_label <- data.frame(x = NA,y = NA,label = row.names(pol_circles)[1],phi=NA,rho=NA)
  factor_label$phi <- pol_circles[which.min(pol_circles$radius),"phi"]+pi/cplx+rotate_title
  factor_label$rho <- 2/3*max(pol_circles$radius)
  factor_label$x <- round(cos(factor_label$phi)*factor_label$rho, digits = 7)
  factor_label$y <- round(sin(factor_label$phi)*factor_label$rho, digits = 7)

  # coordinates of latent factor correlation labels
    # n = 2 * number of correlations (each correlation label appears twice: once in each factor circle)
  n <- cplx*(cplx-1)
  inner_cors <- data.frame(x=rep(NA,n),y=rep(NA,n),V1=rep(NA,n),V2=rep(NA,n),
                           label=rep(NA,n),xnew=rep(NA,n),ynew=rep(NA,n))
    # subfactor list 1 represents a ring (a,b,c,...) moving one element each time matched with
    # subfactor list 2 representing a list with repeated elements (a,a,b,b,...)
    # so all pairs of facets are covered twice, once in every order, excluding self-pairing
  # subfactor list 1
  a <- row.names(data$global$subfactor_cors)
  a <- c(a,a[1])
  b <- NULL
    # matching subfactors from list 1 to all other subfactors in the correct order
      # this uses a workaround instead of a ring
      # where b is the incrementally generated object and a the ring elements [1-n,1] shifted by 1 each iteration
  for(k in 1:cplx) {
    b <- c(b,a[-c(1,cplx+1)])
    a <- a[-1]
    a <- c(a,a[1])
  }
  inner_cors$V1 <- b
    # subfactor list 2
  inner_cors$V2 <- unlist(lapply(row.names(data$global$subfactor_cors),FUN=rep,times=cplx-1))
    # correlation values
  for(k in 1:n) inner_cors$label[k] <- data$global$subfactor_cors[inner_cors$V1[k],inner_cors$V2[k]]
  inner_cors$label <- as.character(inner_cors$label)
  inner_cors$label[inner_cors$label<1] <- substr(inner_cors$label,2,4)
    # label coordinates
  inner_cors$x <- cart_circles[inner_cors$V2,"x"]
  inner_cors$y <- cart_circles[inner_cors$V2,"y"]
    # scatter as list
      # middle of list is anchored towards the origin
      # scatter width resembles the angles of an even n-sided polygon for n subfactors
      # (e.g. 90? = pi/2 for 4 subfactors)
      # labels are distributed in directions that were a perfect fit in an even polygon
  scatter <- rep(seq(from = (-pi+2*pi/cplx)/2,to = (pi-2*pi/cplx)/2,by = (pi-2*pi/cplx)/(cplx-2)),cplx)
  inner_cors$xnew <- inner_cors$x + round(cos(pol_circles[inner_cors$V2,"phi"]+pi+scatter), digits = 7)*(pol_circles[inner_cors$V2,"radius"]-cors*.5*cor_spacing)
  inner_cors$ynew <- inner_cors$y + round(sin(pol_circles[inner_cors$V2,"phi"]+pi+scatter), digits = 7)*(pol_circles[inner_cors$V2,"radius"]-cors*.5*cor_spacing)
  inner_cors$x <- inner_cors$xnew
  inner_cors$y <- inner_cors$ynew
  inner_cors[6:7] <- list(NULL)


    ## coordinates of nested plot objects

  # these objects are put into a list ('nested') next to the data frames containing the global plot objects
  # shifting the coordinates from model_facets to the correct place
  # subcircles is a list of lists, one for each factor, with the shifted coordinates for that factor's nested plot objects
  subcircles <- list()
  for(i in 1:cplx) subcircles[[nam[i]]] <- shift_factor(factorcoors[[nam[i]]],cart_circles[nam[i],"x"],cart_circles[nam[i],"y"])

  # coordinates of facet circles
  # note that the coordinates of the following nested plot objects get bunched together across factors
  nested <- list(circles=NULL,axes=NULL,factor_label=NULL,inner_cors=NULL)
  for(i in 1:cplx) nested$circles[[nam[i]]] <- subcircles[[c(i,1)]]
  nested$circles <- lapply(nested$circles,utils::tail,n=-1)
  nested$circles <- do.call("rbind",nested$circles)
  nested$circles$label <- substr(row.names(nested$circles),unlist(gregexpr(pattern = "\\.",row.names(nested$circles)))+1,nchar(row.names(nested$circles)))

  # coordinates of nested axes
  for(i in 1:cplx) nested$axes[[nam[i]]] <- subcircles[[c(i,2)]]
  nested$axes <- do.call("rbind",nested$axes)

  # coordinates of factor names
  for(i in 1:cplx) nested$factor_label[[nam[i]]] <- subcircles[[c(i,3)]]
  nested$factor_label <- do.call("rbind",nested$factor_label)

  # coordinates of latent facet correlations
  for(i in 1:cplx) nested$inner_cors[[nam[i]]] <- subcircles[[c(i,4)]]
  nested$inner_cors <- do.call("rbind",nested$inner_cors)


    ## (optional) correlation arrows between facets of different factors

  if(!is.null(extra_arrows)){
    # n = number of arrows
    n <- dim(extra_arrows)[1]
    arrows <- data.frame(x1=rep(NA,n),x2=rep(NA,n),y1=rep(NA,n),y2=rep(NA,n),label=rep(NA,n),xlabel=rep(NA,n),ylabel=rep(NA,n))
    arrows$label <- extra_arrows$value
    # coordinates of the correlation arrows
    # note: facet circles are named as 'factor.facet' within nested$circles
    arrows$x1 <- nested$circles[paste(extra_arrows$V1_factor,extra_arrows$V1_subfactor,sep = "."),"x"]
    arrows$y1 <- nested$circles[paste(extra_arrows$V1_factor,extra_arrows$V1_subfactor,sep = "."),"y"]
    arrows$x2 <- nested$circles[paste(extra_arrows$V2_factor,extra_arrows$V2_subfactor,sep = "."),"x"]
    arrows$y2 <- nested$circles[paste(extra_arrows$V2_factor,extra_arrows$V2_subfactor,sep = "."),"y"]
    # shift arrow ends from center to edge of facet circles
    arrows$x1new <- arrows$x1+subradius/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$x2-arrows$x1)
    arrows$x2new <- arrows$x2+subradius/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$x1-arrows$x2)
    arrows$y1new <- arrows$y1+subradius/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$y2-arrows$y1)
    arrows$y2new <- arrows$y2+subradius/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$y1-arrows$y2)
    arrows$x1 <- arrows$x1new
    arrows$x2 <- arrows$x2new
    arrows$y1 <- arrows$y1new
    arrows$y2 <- arrows$y2new
    # coordinates of the correlation labels
    arrows$xlabel <- (arrows$x1+arrows$x2)/2
    arrows$ylabel <- (arrows$y1+arrows$y2)/2
    # letting the correlation labels dodge their arrow by 0.1 sideways
    arrows$xlabel <- arrows$xlabel+.1/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$y2-arrows$y1)
    arrows$ylabel <- arrows$ylabel+.1/sqrt((arrows$x2-arrows$x1)^2+(arrows$y2-arrows$y1)^2)*(arrows$x1-arrows$x2)
    arrows[8:11] <- list(NULL)
    rm(n)
  }
  else arrows <- NULL

  rm(nam,cplx)


    ## return

  # returns a list of lists of all dataframes above containing the coordinates of the plot objects
    # the first element ('factor') is a list of the lists created by model_facets for facet plots
    # the second element ('global') is a list containing the dataframes with coordinates for the nested plot
    # the third (optional) element ('items') is a list of the lists created by model_items for item plots
  global <- list(pol_circles = pol_circles,
                      cart_circles = cart_circles,
                      pol_inner_ring = pol_inner_ring,
                      cart_inner_ring = cart_inner_ring,
                      pol_axes = pol_axes,
                      cart_axes = cart_axes,
                      axis_tick = axis_tick,
                      factor_label = factor_label,
                      inner_cors = inner_cors,
                      nested = nested,
                      relative_scaling = relative_scaling,
                      cor_spacing = cor_spacing,
                      arrows = arrows)

  coor <- list(factor=factorcoors,global=global)
  if(items==T)coor$items <- itemcoors

  return(coor)
}
